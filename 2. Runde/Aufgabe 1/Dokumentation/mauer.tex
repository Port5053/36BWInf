\documentclass[a4paper, 12pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{amssymb}
\usepackage{amsmath}

\usepackage[noline]{algorithm2e}

\usepackage{float}
\usepackage{framed}
\usepackage[hidelinks]{hyperref}

\usepackage{tikz}
\usetikzlibrary{arrows.meta}

\newcommand{\mycommentsty}[1]{\itshape\textcolor{gray}{#1}}
\SetCommentSty{mycommentsty}
\newcommand{\myfuncsty}[1]{\rmfamily {#1}}
\SetFuncSty{myfuncsty}
\SetStartEndCondition{ }{}{}%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{}%
\SetKwFor{While}{while}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwComment{tcp}{}{}%
\SetKwComment{Comment}{}{}%
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetNoFillComment%

\allowdisplaybreaks
\newcommand{\numberthis}{\addtocounter{equation}{1}\tag{\theequation}}
\numberwithin{equation}{section}
\renewcommand{\labelenumi}{(\arabic{enumi})}

\setlength{\parindent}{0pt}

\title{Aufgabe 1\\Die Kunst der Fuge\\Dokumentation}
\author{Kamal Abdellatif}
\date{}

\begin{document}
\maketitle
\section{Obere Schranke}
Die Höhe einer Mauer von beliebigem $n$ ist nach oben beschränkt. Eine Mauer ist so breit wie die Summe der Längen $\ell$ aller Steine in einer Reihe. Da sich zwischen den Steinen nur die Reihenfolge ändert, entspricht die Breite jeder Reihe der Breite $w$ der Mauer.
\begin{equation}\label{eq:width}
	w = \sum_{\ell = 1}^n \ell = \frac{1}{2}n(n+1)
\end{equation}
In jeder Reihe befinden sich genau $n-1$ Fugen, da auf jeden der $n$ Steine in der Reihe genau eine Fuge folgt, mit Ausnahme des letzten Steins. Besitzt die Mauer eine Höhe $h$, so ist die Anzahl aller Fugen in der gesamten Mauer $h(n-1)$.\\
Eine Fuge nimmt entlang der Breite der Mauer eine bestimmte Position ein. Jede mögliche Position ist eine \emph{Spalte}, wobei die $i$-te Spalte den Abstand $i$ zum linken Mauerrand besitzt. Liegt auf einer Spalte eine Fuge, so ist die Spalte \emph{besetzt}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw[ultra thick]
			(0, 0) rectangle ++(1, -1)
			(1, 0) rectangle ++(2, -1)
			(3, 0) rectangle ++(3, -1)
			(0, -1) rectangle ++(2, -1)
			(2, -1) rectangle ++(3, -1)
			(5, -1) rectangle ++(1, -1);

		\node[above] at (-.75, .25) {$i$};
		\foreach \i in {1,...,5} {
			\draw[dashed] (\i, .25) node[above] {\i} -- (\i, -2.25);
		}
	\end{tikzpicture}
	\caption{Spalten einer Mauer}
\end{figure}
Eine Mauer der Breite $w$ besitzt $w-1$ Spalten, da die erste Spalte Distanz $1$ und die letzte Spalte Distanz $w-1$ zum linken Rand aufweist.
% \newpage
Hat eine Mauer keine sich überschneidenden Fugen, so kann jede Spalte von maximal einer Fuge belegt sein. Mit jeder hinzukommenden Reihe werden $n-1$ unbelegte Spalten mit Fugen besetzt. Ist es nicht mehr möglich, eine Reihe hinzuzufügen, ohne dass eine Überschneidung entsteht, ist die höchst mögliche Mauer erreicht. Diese maximale Höhe ergibt sich somit aus dem Quotienten aus der Anzahl aller Spalten und der Anzahl von Fugen pro Reihe.
\begin{align*}
	h(n-1) &\le w-1 \\
	&\le \frac{1}{2}n(n+1) -1 \\
	h &\le \frac{\frac{1}{2}\,n(n+1)-1}{n-1} = \frac{\frac{1}{2}\,n(n-1)+n-1}{n-1} \\
	h &\le \frac{1}{2}n + 1 \numberthis\label{eq:schranke}
\end{align*}
Nur für gerade $n$ nimmt diese obere Schranke ganzzahlige Werte an. Die Schranke ist genau dann erreicht, wenn jede Spalte durch genau eine Fuge belegt ist. Für ungerade $n$ ist die Schranke nie ganzzahlig, sodass sie nie erreicht werden kann. Demnach müssen im ungeraden Fall immer Spalten offen bleiben.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75]
		\draw[very	thick] (0, 0) rectangle (1, 1) (1, 0) rectangle (4, 1) (4, 0) rectangle (6, 1) (6, 0) rectangle (11, 1) (11, 0) rectangle (15, 1) (0, 1) rectangle (2, 2) (2, 1) rectangle (5, 2) (5, 1) rectangle (9, 2) (9, 1) rectangle (14, 2) (14, 1) rectangle (15, 2) (0, 2) rectangle (3, 3) (3, 2) rectangle (7, 3) (7, 2) rectangle (8, 3) (8, 2) rectangle (13, 3) (13, 2) rectangle (15, 3);

		\draw[thick, dashed] (10, -.25) node[above] {} -- (10, 3.25);
		\draw[thick, dashed] (12, -.25) node[above] {} -- (12, 3.25);
	\end{tikzpicture}
	\caption{Offene Spalten bei ungeraden $n$}
\end{figure}
Die größte erreichbare Höhe $h_{max}$ für ungerade $n$ ist gleich der größten ganzen Zahl unter der Schranke. Aus Gleichung (\ref{eq:schranke}) ergibt sich
\begin{equation}\label{eq:height}
	h_{max} = \frac{1}{2}(n-1)+1 = \frac{1}{2}n+1
\end{equation}
Wird diese Höhe erreicht, so ist die Anzahl $r$ der noch offenen Spalten die Differenz aus der Anzahl aller Spalten $w-1$ und der Anzahl besetzter Spalten $h_{max}(n-1)$.
\begin{align*}
	r &= (w-1) - h_{max}(n-1) \\
	&= \left( \frac{n(n+1)}{2} - 1 \right) - \frac{n+1}{2}\,(n-1) \\
	&= \frac{(n+1)(n-1)+n-1}{2}-\frac{(n+1)(n-1)}{2} \\
	&= \frac{1}{2}(n-1) \qquad (2 \nmid [TODO BEAUTIFY] n) \numberthis\label{eq:offen}
\end{align*}
Für eine Mauer ungeraden $n$ ohne Überschneidungen müssen mindestens $r = \frac{1}{2}(n-1)$ Spalten offen bleiben.
\section{Backtrakcing}
\subsection{Vorbetrachtung}
Das Problem wird mit Backtracking gelöst. Es wird davon ausgegangen, dass die nach der oberen Schranke (\ref{eq:schranke}) gegebene größtmögliche Höhe $h = h_{max}$ immer erreichbar ist. Um eine Mauer $n$ zu lösen, wird von einer leeren Mauer der Dimensionen $w \times h$ ausgegangen. Ziel des Backtracking ist es, diese Mauer Stein für Stein zu füllen, ohne dass sich Fugen überschneiden.

Eine Mauer $W = \left\{ R_1,\ \dots,\ R_h \right\}$ besteht aus $h$ Reihen $R$. Während der Konstruktion der Mauer sind die Reihen nur teilweise gefüllt. Eine Reihe $R = \left\{ b_1,\ \dots,\ b_k \right\}$ enthält $k \leq n$ Steine einer bestimmten Länge $b$. Ein Stein $b_i$ ist der $i$-te Stein von links innerhalb der Reihe. Nur die Steine $\Sigma = \left\{ 1,\ \dots,\ n \right\}$ können in einer Reihe $R \subseteq \Sigma$ enthalten sein.

Jede Reihe $R$ besitzt eine Länge $\ell(R)$. Diese Länge ergibt sich aus der Summe aller in $R$ enthaltenen Steinlängen.
\begin{equation}
	\ell(R) = \sum_{b_i \in R} b_i
\end{equation}
Die Reihe endet in der $\ell$-ten Spalte. Diese Spalte wird als \emph{Endpunkt} der Reihe bezeichnet.
% Eine Reihe besitzt $k-1$ Fugen. Die Spalte $f_i$ der $i$-ten Fuge von links in einer Reihe $R$ entspricht der Teilsumme aller Steine bis dorthin.
% \begin{equation}
	% f_i = \sum_{j=1}^i b_j \qquad i < k
% \end{equation}
% Alle von Fugen durch eine Reihe $R$ besetzten Spalten sind in $F(R) = \left\{ f_1,\ \dots,\ f_{k-1} \right\}$ zusammengefasst.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.1]
		\draw[gray, dashed]
			(0, -1) rectangle ++(2, -1)
			(2, -1) rectangle ++(3, -1)
			% (0, -2) rectangle ++(4, -1)
			(4, -2) rectangle ++(2, -1)
			(0,  0) rectangle ++(10, -3);
		\draw[very thick]
			(0, 0) rectangle ++(1, -1)
			(1, 0) rectangle ++(2, -1)
			(3, 0) rectangle ++(4, -1);

		\node at (-.5, -.5) {$R_1$};
		\node[gray] at (-.5, -1.5) {$R_2$};
		\node[gray] at (-.5, -2.5) {$R_3$};

		\node at (.5, -.5)  {{\small$b_1=1$}};
		\node at (2, -.5)   {{\small$b_2=2$}};
		\node at (5, -.5) {{\small$b_3=4$}};

		\draw[|-|, very thick] (0, -1.3) to (7, -1.3) node[right] {$\ell = 7$};

		\node at (8, -.5) {$k = 3$};

		% \draw[thick, -{latex}] (1, .5) node[anchor=south] {$f_1=1$} to (1, .1);
		% \draw[thick, -{latex}] (3, .5) node[anchor=south] {$f_2=3$} to (3, .1);
	\end{tikzpicture}
	\caption{Bezeichnungen}
\end{figure}
\subsection{Gerade Fälle}
In der Lösung einer Mauer mit geraden $n$ ist jede Spalte durch genau eine Fuge besetzt. Um diese Lösung zu konstruieren, werden die Spalten nacheinander von links nach rechts mit Fugen aufgefüllt. Mit jedem Backtracking-Schritt wird eine Spalte gefüllt. Dazu wird ein Stein direkt an das rechte Ende einer Reihe angelegt.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75]
		\draw[very thick] (0, 0) rectangle (15, 3);
		\draw[very thick, fill=white] (0, 0) rectangle (1, 1) (1, 0) rectangle (4, 1) (4, 0) rectangle (6, 1) (0, 1) rectangle (2, 2) (2, 1) rectangle (5, 2) (0, 2) rectangle (3, 3);
		\draw[very thick, gray, fill=white] (3.1, 2.1) rectangle (7.1, 3.1);

		\node at (-.5, 2.5) {$R$};

		\draw[|-{Latex}, thick] (0, -.5) to ++(7, 0) node[right] {$s$};
		\draw[thick, dashed] (7, -.5) -- (7, 3.5);
		\draw[|-|, thick] (0, 3.5) to node[above] {$\ell(R)$} ++(3, 0);
		\draw[|-|, thick] (3, 4) to node[above] {$b'$} ++(4, 0);
	\end{tikzpicture}
	\caption{Anlegen eines Steins}
\end{figure}
Soll eine Reihe $R$ zu der Spalte $s$ erweitert werden, muss ein Stein bestimmter Länge $b'$ hinzugefügt werden. Da die Reihe nach Anfügen des Steins in Spalte $s$ endet, ist der neue Stein genau so lang sein wie die Differenz zwischen $s$ und dem aktuellem Ende der Reihe $\ell$. Dabei darf $b'$ noch nicht in $R$ enthalten sein, da es sonst zu einer Wiederholung kommen würde.
\begin{equation}\label{eq:bprime}
	b' = s-\ell(R) \qquad (b' \in \Sigma \backslash R)
\end{equation}
Nach Anfügen des Steins hat sich in der $R$ die Anzahl $k$ von Steinen um eins erhöht und die Länge um $b'$ vergrößert. Da die Lücke $s$ nun durch eine Fuge gefüllt ist, wird als nächstes die darauf folgende Spalte $s+1$ gefüllt. Dieser Vorgang wird als \emph{Schritt} bezeichnet.
\begin{align}\label{eq:trans}
	R' &= R\,\cup\,\{b'\} & \ell' &= \ell + b' & s' &= s+1
\end{align}
Durch diese Vorgehensweise wird jede Spalte durch genau eine Fuge besetzt und in keiner Reihe wird ein Stein wiederholt. Wurden alle Reihen vollständig gefüllt, so ist eine Lösung gefunden worden.

Das Backtracking öffnet einen neuen Suchzweig für jede mögliche Reihe, die zum Füllen der nächsten Spalte gewählt werden kann. Eine Reihe $R$ kann genau dann gewählt werden, wenn der benötigte Stein $b'$ noch nicht in $R$ enthalten ist. Ist der Stein doch enthalten, oder sein Länge überschreitet $n$, so handelt es sich um eine \emph{Kollision}. Ist keine Reihe mehr möglich, so muss der gesamte Suchzweig verworfen werden.

Das Backtracking geht in Tiefensuche vor und wird rekursiv implementiert. Jeder Rekursionsschritt besteht aus drei Schritten:
\begin{enumerate}
	\item Der zu untersuchende Schritt wird ausgeführt: Der Stein wird an die entsprechende Reihe angefügt und die aktuelle Spalte inkrementiert.
	\item Alle Folgeschritte werden untersucht. Dazu wird durch alle möglichen Reihen iteriert. Der Erfolg des aktuellen Schrittes hängt davon ab, ob mindestens eine davon erfolgreich war.
	\item Die unternommenen Änderungen werden rückgängig gemacht.
\end{enumerate}
Sobald eine Lösung gefunden wurde, wird die Suche abgebrochen. War eine der Möglichkeiten erfolgreich, so werden weitere Möglichkeiten außer acht gelassen, und der Erfolg wird sofort zurückgegeben.

Für den vollständigen Algorithmus in Pseudocode siehe Anhang (\ref{alg:even}).

\subsection{Ungerade Fälle}
Für ungerade $n$ ist nicht mehr gegeben, dass jede Spalte durch genau eine Fuge besetzt wird. Genauer, nach Gleichung (\ref{eq:offen}) bleiben in einer maximalen Lösung genau $r = \frac{1}{2}(n-1)$ Spalten offen.

Um das Backtracking auf alle Fälle zu erweitern, wird die Möglichkeit hinzugefügt, bestimmte Spalten auszulassen. Ist es in einem ungeraden Fall während des Backtracking nicht möglich, die direkt folgende Spalte $s$ zu füllen, so kann diese Spalte \emph{übersprungen} werden. Dazu wird nicht versucht, die Spalte $s$ zu füllen, sondern die darauf folgende Spalte $s+1$.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75]
		\draw[very thick] (0, 0) rectangle ++(4, 1)
		                  (4, 0) rectangle ++(2, 1)
		                  (0, 1) rectangle ++(2, 1)
		                  (2, 1) rectangle ++(3, 1)
		                  (0, 2) rectangle ++(1, 1)
		                  (1, 2) rectangle ++(2, 1)
		                  (3, 2) rectangle ++(4, 1)
		                  (0, 0) rectangle (15, 3);
		\draw[very thick, gray] (6.1, .1) rectangle ++(3, 1);
		\draw[thick, dashed] (8, 3.25) to ++ (0, -3.5) node[below] {$s\vphantom{s+1}$};
		\draw[thick, dashed] (9, -.25) to ++ (0,  3.5) node[above] {$s+1$};
	\end{tikzpicture}
	\caption{Überspringen einer Spalte}
\end{figure}
Ist es auch nicht möglich, die Spalte $s+1$ zu füllen, so wird diese ebenfalls übersprungen. Es ist demnach möglich, auch mehrere Spalten in einem Schritt zu überspringen. Sei $z$ die Anzahl von übersprungenen Spalten in einem Schritt.

Während des Backtrackings soll $r$ die Anzahl von Spalten darstellen, die noch übersprungen werden können. Anfänglich ist $r$ die durch Gleichung (\ref{eq:offen}) gegebene Insgesamtanzahl, insofern $n$ ungerade ist. Handelt es sich um einen geraden Fall, so dürfen keine Spalten übersprungen werden, womit $r=0$.
\begin{equation}
	r =
	\begin{cases}
		0 &\qquad (2 \mid n)\\
		\frac{1}{2}(n-1) &\qquad (2 \nmid n)
	\end{cases}
\end{equation}
Wurden $z$ Spalten übersprungen, so verringert sich $r$ um diese Zahl. Es können mindestens $0$ und maximal $r$ Spalten in einem Schritt übersprungen werden. Da nun nicht immer die direkt folgende Spalte als betrachtet wird, müssen die Gleichungen (\ref{eq:bprime}) und (\ref{eq:trans}) für den Übergang zum nächsten Schritt erweitert werden.
\begin{gather}
	b' = s + z -\ell(R) \qquad (b' \in \Sigma \backslash R \ \wedge\ 0 \le z \le r) \\
	R' = R\,\cup\,\{b'\} \qquad \ell' = \ell + b' \qquad s' = s+z+1 \qquad r' = r - z
\end{gather}
Ein Schritt setzt sich nun zusammen aus einer Reihe $R \in W$ und einer Anzahl von Sprüngen $z \in Z$ mit $Z = \left\{ 0,\ \dots,\ r \right\}$. Die Menge aller Folgeschritte ist die Menge von allen Kombinationen $W \times Z$. Dazu werden die Iterationen über die Reihen und über die Sprunglängen geschachtelt. Die äußere Iteration geht über $z$ aufsteigend. Es werden demnach immer zuerst die Möglichkeiten mit der geringsten Anzahl von Sprüngen betrachtet. Für den erweiterten Algorithmus siehe Anhang (\ref{alg:all}).
\subsection{Suchheuristik}
Mit dem Backtracking wird ein Suchbaum abgelaufen. Jeder Knoten in diesem Baum stellt einen Füllzustand der Wand dar, während ein Schritt von einem Zustand zum nächsten eine Kante ist. Ist kein Schritt von einem Knoten aus mehr möglich, so handelt es sich um eine \emph{Sackgasse}. Ist die Mauer vollständig gefüllt, so ist der zugehörige Zustands-Knoten eine \emph{Lösung}. Alle Blätter des Baums sind entweder Sackgassen oder Lösungen.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75, y=8mm]
		\def\checkmark{\tikz\fill[scale=0.4](0, .35) -- (.25, 0) -- (.6, .7) -- (.25, .15) -- cycle;} 
		\tikzstyle{node}=[draw, thick, circle, inner sep=0pt, minimum width=5mm]
		\large
		\node[node] (a) at (0, 6) {};
		\node[node] (b1) at (-4, 4) {};
		\node[node] (b2) at (0, 4) {};
		\node[node] (b3) at (4, 4) {};
		\node[node] (c11) at (-5, 2) {};
		\node[node] (c12) at (-4, 2) {};
		\node[node] (c13) at (-3, 2) {$\times$};
		\node[node] (c22) at (0, 2) {};
		\node[node] (c23) at (1, 2) {$\times$};
		\node[node] (c33) at (4, 2) {$\times$};
		\node[node] (d111) at (-7, 0) {$\times$};
		\node[node] (d112) at (-6, 0) {$\times$};
		\node[node] (d113) at (-5, 0) {$\times$};
		\node[node] (d122) at (-4, 0) {$\times$};
		\node[node] (d221) at (-1, 0) {$\times$};
		\node[node] (d222) at (0, 0) {\checkmark};
		\draw[-{latex}, thick] (a) edge (b1) (a) edge (b2) (a) edge (b3)
		                 (b1) edge (c11) (b1) edge (c12) (b1) edge (c13)
		                 (b2) edge (c22) (b2) edge (c23)
		                 (b3) edge (c33)
		                 (c11) edge (d111) (c11) edge (d112) (c11) edge (d113)
		                 (c12) edge (d122)
		                 (c22) edge (d221) (c22) edge (d222);
	\end{tikzpicture}
	\caption{Suchbaum}
\end{figure}
Das Backtracking geht den gesamten Baum ab, bis eine Lösung gefunden wurde. Die Größe des Baums, der bis zur ersten gefundenen Lösung betrachtet werden musste, ist maßgebend für die Laufzeit der Suche. Dabei ist die Reihenfolge entscheidend, in der die einzelnen Möglichkeiten abgelaufen werden.
\par
\begin{minipage}{.45\textwidth}
	\begin{figure}[H]
		\begin{tikzpicture}[scale=.75, x=9mm, y=8mm]
			\def\checkmark{\tikz\fill[x=4mm, y=4mm](0, .35) -- (.25, 0) -- (.6, .7) -- (.25, .15) -- cycle;} 
			\tikzstyle{node}=[draw, thick, circle, inner sep=0pt, minimum width=5mm]
			\large
			\node[node] (a) at (0, 6) {};
			\node[node] (b1) at (-4, 4) {};
			\node[node] (b2) at (0, 4) {};
			\node[node, opacity=.2] (b3) at (4, 4) {};
			\node[node] (c11) at (-5, 2) {};
			\node[node] (c12) at (-4, 2) {};
			\node[node] (c13) at (-3, 2) {$\times$};
			\node[node] (c22) at (0, 2) {};
			\node[node, opacity=.2] (c23) at (1, 2) {$\times$};
			\node[node, opacity=.2] (c33) at (4, 2) {$\times$};
			\node[node] (d111) at (-7, 0) {$\times$};
			\node[node] (d112) at (-6, 0) {$\times$};
			\node[node] (d113) at (-5, 0) {$\times$};
			\node[node] (d122) at (-4, 0) {$\times$};
			\node[node] (d221) at (-1, 0) {$\times$};
			\node[node] (d222) at (0, 0) {\checkmark};
			\draw[-{latex}, thick] (a) edge (b1) (a) edge (b2) (a) edge[opacity=.2] (b3)
			                 (b1) edge (c11) (b1) edge (c12) (b1) edge (c13)
			                 (b2) edge (c22) (b2) edge[opacity=.2] (c23)
			                 (b3) edge[opacity=.2] (c33)
			                 (c11) edge (d111) (c11) edge (d112) (c11) edge (d113)
			                 (c12) edge (d122)
			                 (c22) edge (d221) (c22) edge (d222);
		\end{tikzpicture}
		\caption{Betrachteter Teilbaum von links nach rechts}
	\end{figure}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\begin{figure}[H]
		\begin{tikzpicture}[scale=.75, x=9mm, y=8mm]
			\def\checkmark{\tikz\fill[x=4mm, y=4mm](0, .35) -- (.25, 0) -- (.6, .7) -- (.25, .15) -- cycle;} 
			\tikzstyle{node}=[draw, thick, circle, inner sep=0pt, minimum width=5mm]
			\tikzstyle{node_}=[draw, thick, circle, inner sep=0pt, minimum width=5mm, opacity=.2]
			\large
			\node[node] (a) at (0, 6) {};
			\node[node_] (b1) at (-4, 4) {};
			\node[node] (b2) at (0, 4) {};
			\node[node] (b3) at (4, 4) {};
			\node[node_] (c11) at (-5, 2) {};
			\node[node_] (c12) at (-4, 2) {};
			\node[node_] (c13) at (-3, 2) {$\times$};
			\node[node] (c22) at (0, 2) {};
			\node[node] (c23) at (1, 2) {$\times$};
			\node[node] (c33) at (4, 2) {$\times$};
			\node[node_] (d111) at (-7, 0) {$\times$};
			\node[node_] (d112) at (-6, 0) {$\times$};
			\node[node_] (d113) at (-5, 0) {$\times$};
			\node[node_] (d122) at (-4, 0) {$\times$};
			\node[node_] (d221) at (-1, 0) {$\times$};
			\node[node] (d222) at (0, 0) {\checkmark};
			\draw[-{latex}, thick, opacity=.2] (a) edge (b1)  
			                 (b1) edge (c11) (b1) edge (c12) (b1) edge (c13)
			                 (c11) edge (d111) (c11) edge (d112) (c11) edge (d113)
			                 (c12) edge (d122)
			                 (c22) edge (d221);
			\draw[-{latex}, thick]
			                 (a) edge (b2)
			                 (a) edge (b3)
			                 (b2) edge (c22)
			                 (b2) edge (c23)
			                 (b3) edge (c33)
			                 (c22) edge (d222);
		\end{tikzpicture}
		\caption{Betrachteter Teilbaum von rechts nach links}
	\end{figure}
\end{minipage}
\\\\\\
Um die Laufzeit der Suche zu verringern, wird eine Suchheuristik angewendet, welche die Reihenfolge der betrachteten Möglichkeiten beeinflusst. Eine solche Heuristik sollte die Schritte zuerst wählen, die eine höhere Wahrscheinlichkeit haben, zielführend zu sein. So verringert sich die durchschnittliche Größe des betrachtenten Teilbaums. Ausschlaggebend für diese Größe ist unter Anderem die Anzahl von vorgekommenen Kollisionen.
\\\\
Werden die Reihen immer in der gleichen Reihenfolge betrachtet, entsteht eine Ungleichgewichtung in den Steinlängen. Es wird immer versucht, die nächste Fuge zuerst in den oben liegenden Reihen zu setzen. So werden tendenziell mehr Fugen in den oberen Reihen und weniger in den unteren gesetzt. Eine höhere Dichte an Fugen führt zu kleineren Steinlängen. Daher füllen sich die oberen Reihen zuerst mit kurzen Steinlängen und die unteren mit Langen. Dieses Verhalten erzeugt eine erhöhte Anzahl von Kollisionen: Werden beispielsweise in den oberen Reihen kurze Steinlängen bevorzugt, so ist es beim Anfügen eines weiteren kurzen Steins warscheinlicher, dass dieser schon verwendet wurde. Gleiches gilt für die unteren Reihen mit langen Steinen.

Werden die Fugen anfänglich nur oben gesetzt, so können untere Reihen sogar so weit zurückfallen, dass selbst der längste Stein nicht zum Auffüllen ausreicht. Da die unteren Reihen erst dann betrachtet werden, wenn alle Oberen keine Kapazität mehr haben, werden diese Suchzweige erst sehr spät abgebrochen. Dies führt zu vollständigen Suchzweigen, die verworfen werden müssen, da die unteren Reihen von Anfang an nicht mehr füllbar waren.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75]
		\draw[ultra thick] (0, 1) rectangle ++(4, 1)
		                  (4, 1) rectangle ++(3, 1)
		                  (7, 1) rectangle ++(1, 1)
		                  (0, 2) rectangle ++(2, 1)
		                  (2, 2) rectangle ++(3, 1)
		                  (5, 2) rectangle ++(4, 1)
		                  (0, 3) rectangle ++(1, 1)
		                  (1, 3) rectangle ++(2, 1)
		                  (3, 3) rectangle ++(3, 1)
		                  (6, 3) rectangle ++(4, 1)
		                  (0, 0) -- (0, 4) -- (15, 4)
		                  (0, 0) -- (15, 0);
		% \path[{latex}-, dashed, thick](1, -0.5) edge (1, 3)
		                     % (2, -0.7) edge (2, 2)
		                     % (3, -0.9) edge (3, 3)
		                     % (4, -1.1) edge (4, 1)
		                     % (5, -1.3) edge (5, 2)
		                     % (6, -1.5) edge (6, 3);
		% \draw[ultra thick, gray, fill=white] (0, -1.5) rectangle ++(6, -1);
		% \draw[ultra thick, gray, fill=white] (0, -1.3) rectangle ++(5, -1);
		% \draw[ultra thick, gray, fill=white] (0, -1.1) rectangle ++(4, -1);
		% \draw[ultra thick, gray, fill=white] (0, -0.9) rectangle ++(3, -1);
		% \draw[ultra thick, gray, fill=white] (0, -0.7) rectangle ++(2, -1);
		% \draw[ultra thick, gray, fill=white] (0, -0.5) rectangle ++(1, -1);

		\draw[dashed, very thick] (11, -.25) -- (11, 4.25);
	\end{tikzpicture}
	\caption{erste Sackgasse im Backtracking für $n=6$}\label{fig:sackgasse}
\end{figure}
Im Beispiel von Abbildung (\ref{fig:sackgasse}) können die oberen drei Reihen nicht besetzt werden, da die benötigten Steine schon verbaut sind. Allerdings sind schon die ersten zehn Spalten besetzt, sodass seit vier Schritten schon die unterste Reihe nicht mehr besetzbar war.
\\\\
Im Anhang (TODO ref me) wird die Kollisionshäufigkeit genauer statistisch untersucht. Die Beobachtungen unterstützen die obigen Vorhersagen?
\\\\
Die gewählte Heuristik wirkt diesen Effekten entgegen.
\begin{framed}
	\centering
	Reihen werden nach aufsteigender Länge betrachtet.
\end{framed}
Durch Ordnung nach aufsteigender Länge werden immer zuerst die kürzesten Reihen betrachtet. So bleibt die Längenverteilung innerhalb der Reihen gleichmäßig, da keine Reihe zurückfallen kann. Das Anfügen eines Steins verlängert die gewählte Reihe. Da bis zu einer bisher ungefüllten Spalte aufgefüllt wird, ist die Reihe nach Auffüllen die längste Reihe der Mauer. Die Reihenfolge der restlichen Reihen bleibt erhalten.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=.75]
		\draw[very thick] (0, 0) rectangle (15, 3);
		\draw[very thick, fill=white]
		(0, 0) rectangle (1, 1)
		(1, 0) rectangle (4, 1)
		(4, 0) rectangle (6, 1)
		(0, 1) rectangle (2, 2)
		(2, 1) rectangle (5, 2)
		(0, 2) rectangle (3, 3);
		\draw[very thick, gray, fill=white] (3.1, 2.1) rectangle (7.1, 3.1);
	\end{tikzpicture}
	\caption{Bla}
\end{figure}
\newpage
\section{Anhang}
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwData{$n$ \tcp*[f]{Eingabe für gerade $n$}}\;
	\KwResult{solved $W$ \tcp*[f]{vollständige Mauer ohne Überschneidungen}}\;
	\SetKwFunction{FMain}{putStone}
	\SetKwProg{Fn}{def}{:}{}
	$h \leftarrow \frac{1}{2}n + 1$\Comment*[f]{Gl.(\ref{eq:width})[TODO INDENTS]}\; \vspace{3pt}
	$w \leftarrow \frac{1}{2}n(n+1)$\Comment*[f]{Gl. (\ref{eq:height})}\;
	$W \leftarrow \left\{ \emptyset \right\}^h$\;
	$s \leftarrow 1$\;
	\Fn(\tcp*[f]{Rekursive Funktion}){\FMain{$R,\ b$}}{
		$s \leftarrow s + 1$\;
		$\ell(R) \leftarrow \ell(R) + b$\;
		$R \leftarrow R\,\cup\,\{b\}$\;
		\If{$s = w$}{
			\Return \textbf{True}\;
		}
		\For{$R'$ \KwTo $W$}{
			$b' \leftarrow s - \ell(R')$\Comment*[f]{Gl. (\ref{eq:bprime})}\;
			\If{$b' \notin R'$}{
				\If{\FMain{$R',\ b'$}}{
					\Return \textbf{True}\;
				}
			}
		}
		$s \leftarrow s - 1$\;
		$R \leftarrow R\backslash\{b\}$\;
		$\ell(R) \leftarrow \ell(R) - b$\;
		\Return \textbf{False}\;
		}
		\BlankLine\;
		\For{$R$ \KwTo $W$}{
			\FMain{$R,\ 1$}\;
		}
	\caption{Backtracking für gerade $n$}\label{alg:even}
\end{algorithm}
\newpage
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwData{$n$ \tcp*[f]{Eingabe für gerade $n$}}\;
	\KwResult{solved $W$ \tcp*[f]{vollständige Mauer ohne Überschneidungen}}\;
	\SetKwFunction{FMain}{putStone}
	\SetKwProg{Fn}{def}{:}{}
	$h \leftarrow \left\lfloor\frac{1}{2}n\right\rfloor + 1$\Comment*[f]{Gl.(\ref{eq:width})[TODO INDENTS]}\;\vspace{3pt}
	$w \leftarrow \frac{1}{2}n(n+1)$\Comment*[f]{Gl. (\ref{eq:height})}\;
	$W \leftarrow \left\{ \emptyset \right\}^h$\;
	\eIf{$2 \mid n$}{
		$r \leftarrow 0$\;
	}{
		$r \leftarrow \frac{1}{2}(n-1)$\;
	}
	$s \leftarrow 1$\;
	\Fn(\tcp*[f]{Rekursive Funktion}){\FMain{$R,\ b,\ z$}}{
		$s \leftarrow s + z + 1$\;
		$\ell(R) \leftarrow \ell(R) + b$\;
		$R \leftarrow R\,\cup\,\{b\}$\;
		\If{$s+z = w$}{
			\Return \textbf{True}\;
		}
		$r \leftarrow r - z$\;
		$Z \leftarrow \left\{ 0,\ \dots,\ r \right\}$\;
		\For{$(R',\ z')$ \KwTo $W \times Z$}{
			$b' \leftarrow s + z' - \ell(R')$\Comment*[f]{Gl. (\ref{eq:bprime})}\;
			\If{$b' \notin R'$}{
				\If{\FMain{$R',\ b',\ z'$}}{
					\Return \textbf{True}\;
				}
			}
		}
		$s \leftarrow s - 1$\;
		$r \leftarrow r + z$\;
		$R \leftarrow R\backslash\{b\}$\;
		$\ell(R) \leftarrow \ell(R) - b$\;
		\Return \textbf{False}\;
		}
		\BlankLine\;
		\For{$R$ \KwTo $W$}{
			\FMain{$R,\ 1,\ 0$}\;
		}
	\caption{Backtracking für alle $n$}\label{alg:all}
\end{algorithm}
\end{document}